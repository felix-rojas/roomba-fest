# -*- coding: utf-8 -*-
"""Reto_multiagentes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/felix-rojas/roomba-colab/blob/main/Reto_multiagentes.ipynb
"""

dependencies = ["mesa", "numpy", "pandas"]

import importlib
import subprocess
import sys

def install_and_import(needed_package):
    try:
        importlib.import_module(needed_package)
        print(f"{needed_package} is already installed")
    except ImportError:
        print(f"{needed_package} is not installed, installing now...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", needed_package])
        print(f"{needed_package} has been installed")

for package in dependencies:
    install_and_import(package)

# Commented out IPython magic to ensure Python compatibility.
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model

# Debido a que necesitamos que exista más de un agente por celda, elegimos ''MultiGrid''.
from mesa.space import MultiGrid

# Con ''RandomActivation'', hacemos que todos los agentes se activen ''al mismo tiempo''.
from mesa.time import RandomActivation

# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import random
import heapq
MAXVAL = 10000

"""##"""

def generate_test_grid(width = 10, height = 10, wall_percentage=0.2, max_garbage_per_cell=8, min_empty_cells = 0.5):
    test_grid = np.random.choice(max_garbage_per_cell,width*height).astype("str")
    min_empty_cells = int(round(min_empty_cells * (width * height)))
    wall_qty = int(round(wall_percentage * (width * height)))
    for _ in range(wall_qty): test_grid[_] = "X"
    for _ in range(wall_qty, min_empty_cells): test_grid[_] = "0"
    test_grid[0] = "P"
    np.random.shuffle(test_grid)
    test = test_grid.reshape(width,height)
    return test, np.argwhere(test=="P")[0]

example_office, example_papelera = generate_test_grid()
print(example_office)
print(example_papelera)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile grid.txt
# 6 5
# 0 4 X 6 0
# 6 X 0 X 4
# 0 X 7 X 0
# 5 0 0 X 8
# 0 0 X 0 0
# 0 0 0 0 P

"""# Global params"""

DEBUG = True
file_name = 'grid.txt'

def leer_grid(nombre_archivo):
  with open(nombre_archivo, 'r') as archivo:
    lineas = archivo.readlines()
    n, m = map(int, lineas[0].split())
    oficina_ = []
    papelera_pos_ = None
    for i in range(1, n + 1):
      fila = lineas[i].strip().split()
      oficina_.append(fila)
      if 'P' in fila:
        papelera_pos_ = (i - 1, fila.index('P'))
    return oficina_, papelera_pos_, n, m

# Llama a la función para leer el archivo
#OFICINA, PAPELERA_POS, alto, ancho = leer_grid(file_name)
ALTO = 5
ANCHO = 6
OFICINA, PAPELERA_POS = generate_test_grid(ANCHO,ALTO)
print(OFICINA)
print(PAPELERA_POS)

class Basura(Agent):
    def __init__(self, unique_id, model, cantidad):
        super().__init__(unique_id, model)
        self.qty = cantidad
        self.agents_on_top = None

    def notify(self, AgenteRobot):
        AgenteRobot.clean()

    def step(self):
        self.agents_on_top = model.grid.get_cell_list_contents([self.pos])

        if self.agents_on_top:
            for agent in self.agents_on_top:
                if isinstance(agent, AgenteRobot):
                    self.notify(agent)

class Obstaculo(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)

class Papelera(Agent):
    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.position = self.pos

def NewShuffle(arr):
  mutable_arr = [list(item) for item in arr]
  n = len(mutable_arr)
  for i in range(n - 1, 0, -1):
    j = np.random.randint(0, i)
    mutable_arr[i], mutable_arr[j] = mutable_arr[j], mutable_arr[i]

  # Convertir de nuevo a lista de tuplas
  return [tuple(item) for item in mutable_arr]

def reconstruct_path(came_from, current):
    total_path = [current]
    while current in came_from:
        current = came_from[current]
        if current:
            total_path.append(current)
    total_path.reverse()
    return total_path

def heuristic(a, b):
    # manhattan distance
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star_search(grid, start, goal):
    open_list = []
    heapq.heappush(open_list, (0, start))
    came_from = {start: None}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}
    while open_list:
      _, current = heapq.heappop(open_list)
      if np.all(current == goal):
        return reconstruct_path(came_from, current)
      neighbors = grid.get_neighborhood(current, moore=True, include_center=False)
      for neighbor in neighbors:
        if grid.out_of_bounds(neighbor):
          continue
        cell_contents = grid.get_cell_list_contents(neighbor)
        if any(isinstance(obj, Obstaculo) for obj in cell_contents):
          continue
        tentative_g_score = g_score[current] + 1
        if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
          came_from[neighbor] = current
          g_score[neighbor] = tentative_g_score
          f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
          heapq.heappush(open_list, (f_score[neighbor], neighbor))

    return None  # No se encontró ningún camino

#Nombre: AgenteRobot
#Parametros: Ninguno.
#Return: Nada
#Se encarga de servir como base para crear agentes de tipo aspiradora
class AgenteRobot(Agent):
  def __init__(self, id, model):
    super().__init__(id, model)
    self.capacity = 5
    self.carrying = 0
    self.returning = False
    self.path_to_papelera = []
    self.steps_since_last_path_update = 0

  def almacenamiento(self):
    print(f'El robot {self.unique_id} tiene actualmente {self.carrying} unidades de basura')

  def clean(self):
    cell_contents = self.model.grid.get_cell_list_contents([self.pos])
    trash_in_cell = [obj for obj in cell_contents if isinstance(obj, Basura)]
    trash_count = len(trash_in_cell)
    if trash_count > 0:
      if trash_count <= (self.capacity - self.carrying):
        to_collect = trash_in_cell
      else:
        to_collect = trash_in_cell[:self.capacity - self.carrying]
      for trash in to_collect:
        self.model.grid.remove_agent(trash)
        self.carrying += 1
        if DEBUG:
            print(f"Robot {self.unique_id} recogió basura en {self.pos}. Almacenamiento: {self.carrying}/{self.capacity}")

  def empty(self):
    self.carrying = 0
    self.returning = False
    if DEBUG:
        print(f"Robot {self.unique_id} vació su contenido en la papelera.")

  def find_path_to_papelera(self):
    self.path_to_papelera = a_star_search(self.model.grid, self.pos, self.model.papelera_coords)
    if self.path_to_papelera:
      self.path_to_papelera.pop(0)  # Remove the current position

  #def move(self):
    #if self.returning and self.path_to_papelera:
     # new_position = self.path_to_papelera.pop(0)
      #self.model.grid.move_agent(self, new_position)
      #if np.all(new_position == self.model.papelera_coords):
       # self.empty()
    #else:
     # options=self.model.grid.get_neighborhood(self.pos,moore = True, include_center=False)
      #valid_moves = []
      #for pos in options:
       # cell_contents = self.model.grid.get_cell_list_contents(pos)
       # if not any(isinstance(obj, (Obstaculo, AgenteRobot)) for obj in cell_contents):
        #  valid_moves.append(pos)

      #if valid_moves:
       # new_position = random.choice(valid_moves)
        #self.model.grid.move_agent(self, new_position)

  def move(self):
    if self.returning:
      print(f"Robot {self.unique_id} retoma su camino hacia la papelera.")
      if not self.path_to_papelera or self.steps_since_last_path_update >= 4:
        self.find_path_to_papelera()
        self.steps_since_last_path_update = 0
      if self.path_to_papelera:
        new_position = self.path_to_papelera.pop(0)
        self.model.grid.move_agent(self, new_position)
        self.steps_since_last_path_update += 1
        if np.all(new_position == self.model.papelera_coords):
          self.empty()
    else:
      print(f"Robot {self.unique_id} Moviendose al azar")
      options = self.model.grid.get_neighborhood(self.pos, moore=True, include_center=False)
      valid_moves = []
      for pos in options:
        cell_contents = self.model.grid.get_cell_list_contents(pos)
        if not any(isinstance(obj, (Obstaculo, AgenteRobot)) for obj in cell_contents):
          valid_moves.append(pos)
        if valid_moves:
          new_position = random.choice(valid_moves)
          self.model.grid.move_agent(self, new_position)

  def step(self):
    self.almacenamiento()
    if self.carrying > 0:
      if not self.returning:
        self.returning = True
        self.find_path_to_papelera()
    if not self.returning:
      self.clean()  # Collect trash in the current cell
    self.move()   # Move to a new cell or towards the papelera

#Nombre: getGrid
#Parametros: un model.
#Return: Nada
#Se encarga de crear una representación visual del estado actual de la cuadrícula en el modelo
def getGrid(model):
    grid = np.zeros((model.grid.width, model.grid.height))
    for x in range(model.grid.width):
        for y in range(model.grid.height):
            if not model.grid.is_cell_empty((x, y)):
                contents = model.grid.get_cell_list_contents((x, y))
                if any(isinstance(agent, Basura) for agent in contents):
                    grid[x][y] = 2  # Asignar 1 si hay una basura en la celda
                elif any(isinstance(agent, AgenteRobot) for agent in contents):
                    grid[x][y] = 4  # Asignar 2 si hay un agente robot en la celda
                elif any(isinstance(agent, Obstaculo) for agent in contents):
                    grid[x][y] = 1  # Asignar 3 si hay un agente obstaculo en la celda
                elif any(isinstance(agent, Papelera) for agent in contents):
                    grid[x][y] = 3  # Asignar 5 si hay un agente papelera en la celda
            else:
                grid[x][y] = 0  # Celda vacía
    return grid

"""## Modelo Oficina

"""

class OficinaModel(Model):
  def __init__(self, width, height, num_agents = 5):
    super().__init__()
    self.cells = np.zeros((width, height))
    self.num_agents = num_agents
    self.grid = MultiGrid(width, height, False)
    self.schedule = RandomActivation(self)
    self.currentStep = 0
    self.numBasuraTotal = 0
    self.basuraRestante = 0
    self.width = width
    self.height = height
    self.initial_grid, self.papelera_coords = generate_test_grid(width=width, height=height)

    self.datacollector = DataCollector(model_reporters = {"Grid" : getGrid })

    obstaculo_id = 0
    basura_id = 0
    for i in range(width):
      for j in range(height):
        if self.initial_grid[i][j] == 'X':
          new_obstaculo = Obstaculo(obstaculo_id, self)
          self.grid.place_agent(new_obstaculo, (i, j))
          obstaculo_id += 1
        elif self.initial_grid[i][j] == 'P':
          new_papelera = Papelera(1, self)
          self.papelera_coords = (i, j)
          self.grid.place_agent(new_papelera, (i, j))
          if DEBUG:
            print(f'La papelera fue colocada en: {(i,j)} y su ubicacion correcta es: {self.papelera_coords}')
        elif self.initial_grid[i][j].isdigit():
          num = int(self.initial_grid[i][j])  # Cantidad de basura
          for _ in range(num):
            new_basura = Basura(basura_id, self, num)
            self.grid.place_agent(new_basura, (i, j))
            basura_id += 1
            self.numBasuraTotal += 1
          if DEBUG:
            print(f'Basura colocada en: {(i,j)} con una cantidad de: {num}')

    for i in range(self.num_agents):
      empty_positions = self.grid.empties
      if empty_positions:
        position = self.random.choice(list(empty_positions))
        agent = AgenteRobot(i, self)
        self.grid.place_agent(agent, position)
        self.schedule.add(agent)

  def allAgentsEmpty(self):
       empty = all(agent.carrying == 0 for agent in self.schedule.agents if isinstance(agent, AgenteRobot))
       print(f'Agentes vacíos: {empty}')
       return empty


  #def allCellClean(self):
    #self.basuraRestante = sum(isinstance(agent, Basura) for agent in self.schedule.agents)
    #print(f'Basura restaste es: {self.basuraRestante}')
    #if (self.numBasuraTotal - self.basuraRestante) == 0:
      #return True

  def allCellClean(self):
    self.basuraRestante = sum(isinstance(obj, Basura) for cell in self.grid.coord_iter() for obj in cell[0])
    print(f'Basura restante es: {self.basuraRestante}')
    return self.basuraRestante == 0

  def SimulationDone(self):
    if self.allCellClean() and self.allAgentsEmpty():
      return True
    else:
      return False

  def SimulationDonecomprobation(self):
    all_clean = self.allCellClean()
    all_empty = self.allAgentsEmpty()
    print(f'SimulationDone -> all_clean: {all_clean}, all_empty: {all_empty}')
    return all_clean and all_empty

  def step(self):
    self.datacollector.collect(self)
    self.schedule.step()
    if self.allCellClean() and self.allAgentsEmpty():
            print(f'Todas las celdas están limpias y todos los robots han vaciado su basura en {self.currentStep} pasos.')
    self.currentStep += 1
    self.SimulationDonecomprobation()

"""## Corrida de simulación"""

MAX_ITER = 2000
AGENT_NUM = 5
startTime = time.time()
model = OficinaModel(ANCHO, ALTO, AGENT_NUM)

ITERCOUNT = 1
#while iter_count < MAX_ITER and not model.SimulationDone():
while model.SimulationDone()==False:
  model.step()
  ITERCOUNT = ITERCOUNT + 1

print(f'La basura total colocada es: {model.numBasuraTotal}')
print(f'La basura restante es: {model.basuraRestante}')
print(f'La simulacion acabó en: {model.currentStep} steps')

#Obtenemos la informacion requerida para el analsis.
all_grid = model.datacollector.get_model_vars_dataframe()
all_grid.describe()

"""## Graficación y visualización
Obtenemos la informacion en cada step y la graficamos para después juntarla en una animación.

Azul oscuro tirando a morado: Obstáculos
Azul turquesa (Azul claro): Basura
Verde: Papelera
Morado: Celda vacía
Amarillo: Agente robot
"""

fig, axs=plt.subplots(figsize=(8,8))
axs.set_xticks([])
axs.set_yticks([])

patch = plt.imshow(all_grid["Grid"][0], cmap='viridis')

def animate(i):
    patch.set_data(all_grid["Grid"][i])

anim = animation.FuncAnimation(fig, animate, frames=ITERCOUNT-1, repeat=False)
plt.show()

"""## Visualización
Se puede guardar en archivo, de así desearlo quitando el comentario
"""

ITERCOUNT

anim
#anim.save("thing.mp4")

"""# Corridas en Batch
¡Sólo correr si necesitas hacer pruebas estadísticas!
Esto se tarda ***mínimo*** 3 minutos

from mesa import batch_run
DEBUG = False
params = {
    "num_agents": [1,5,10],
    "width":[5,10,20],
    "height":[5,10,20]
}

BATCH_ITERATIONS = 100

result_batch = batch_run(
    OficinaModel,
    parameters= params,
    iterations=BATCH_ITERATIONS, # 100 iterations per type of run for a simple distribution
    number_processes=None, # si tienes pocos CPU's, cambia a 1
    data_collection_period=1,
    display_progress=True,
    max_steps=1500
)
"""

#result_batch

# Server run and definition

from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import json

class Server(BaseHTTPRequestHandler):
    
    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        
    def do_GET(self):
        self._set_response()
        self.wfile.write("GET request for {}".format(self.path).encode('utf-8'))

    def do_POST(self):
        """
        Report the agent position to Unity 
        """
        position = {
            "x" : 1,
            "y" : 2,
            "z" : 3
        }

        self._set_response()
        self.wfile.write(str(position).encode('utf-8'))


def run(server_class=HTTPServer, handler_class=Server, port=8585):
    logging.basicConfig(level=logging.INFO)
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info("Starting httpd...\n") # HTTPD is HTTP Daemon!
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:   # CTRL+C stops the server
        pass
    httpd.server_close()
    logging.info("Stopping httpd...\n")

if __name__ == '__main__':
    from sys import argv
    
    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()

